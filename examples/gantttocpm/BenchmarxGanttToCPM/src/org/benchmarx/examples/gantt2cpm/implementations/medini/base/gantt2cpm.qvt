transformation gantt2cpm(diagram : gantt, network : cpm) {
	/* Bidirectional transformation between Gantt diagrams and CPM networks.
	 * The forward transformation maps both activities and dependencies to 
	 * activities in a CPM network. The source and target events of activities
	 * for dependencies depend on the dependency type. The backward
	 * transformation inverts the forward transformation only for
	 * networks which could have been generated by the forward transformation.
	 *
     * The backward transformation relies on a naming convention to decide
     * whether a CPM activity has to be mapped to a Gantt activity or to a
     * Gantt dependency.
	 */

    top relation Diagram2Network {
        name : String;
        
        enforce domain diagram gd_diagram : gantt::GanttDiagram {
        	name = name
        };
        
        enforce domain network cn_network : cpm::CPMNetwork {
        	name = name
        };
    }

    top relation Activity2Activity {
    	name : String; 
    	duration : Integer;
    	
		enforce domain diagram gd_activity : gantt::Activity {
			name = name,
			duration = duration,
			diagram = gd_diagram : gantt::GanttDiagram {}
		};
		
		enforce domain network cn_activity : cpm::Activity  {
			name = name,
			duration = duration,
			network = cn_network : cpm::CPMNetwork {},
			sourceEvent = cn_sourceEvent : cpm::Event {
				network = cn_network
			},
			targetEvent = cn_targetEvent : cpm::Event {
				network = cn_network
			} 
		}; 
		
		when {
			Diagram2Network(gd_diagram, cn_network);
            nameOfActivity(name); 
            /* Backward transformation
             * Should be moved to the network domain condition.
             * Unfortunately, medini QVT ignores domain conditions.
             * As it stands, the expression is not compliant
             * with Annex B of the standard (variables in the when
             * clause must be bound first).
             */
		}
	}

	top relation Activity2ActivityWithNumberedEvents {
		sourceEventNumber, targetEventNumber : Integer;
				
		checkonly domain diagram gd_activity : gantt::Activity {};
		
		enforce domain network cn_activity : cpm::Activity {
			sourceEvent = cn_sourceEvent : cpm::Event {
				number = sourceEventNumber
			}, 
			targetEvent = cn_targetEvent : cpm::Event {
				number = targetEventNumber
			} 
		};
		
		when {
			Activity2Activity(gd_activity, cn_activity);
			cn_sourceEvent = cn_activity.sourceEvent;
			cn_targetEvent = cn_activity.targetEvent;
			/* The variables cn_sourceEvent and cn_targetEvent are bound in the when
			 * clause to avoid the creation of fresh copies.
			 */
			cn_sourceEvent.number = 0; cn_targetEvent.number = 0;
			/* The condition stated above is satisfied in an enforcing forward
			 * transformation, but it fails in a checkonly forward transformation
			 * under the assumption that the event numbers must be unique in
			 * a consistent CPM network.
			 */
			sourceEventNumber = maxEventNumber(cn_activity.network) + 1;
			targetEventNumber = sourceEventNumber + 1;
		}
	} -- Forward enforce transformation
	/* The numbering of events is factored out into a separate top-level
	 * relation to be absolutely sure that all required links have been
	 * set before the number is calculated and assigned. 
	 * The relation is relevant only for the forward enforce transformation.
	 * It generates unique event numbers such that the number of the source
	 * event is odd and incrementing the source event number yields the
	 * target event number. 
	 * In a checkonly transformation, the when clause is not satisfiable
	 * under the assumption that events are numbered in a unique way in a
	 * consistent CPM network. The same argument applies to an enforce
	 * transformation in backward direction. Thus, the relation is effective
	 * only for an enforce forward transformation. 
	 */
	 
    top relation StartStartDependency2Activity {
		offset : Integer;
		name : String;
		cn_sourceEvent, cn_targetEvent : cpm::Event;
		
		enforce domain diagram gd_diagram : gantt::GanttDiagram {
			elements = gd_dependency : gantt::Dependency {
				offset = offset,
				predecessor = gd_predActivity : gantt::Activity{},
				successor = gd_succActivity : gantt::Activity{},
				dependencyType = gantt::DependencyType::StartStart
			}
		};
		
		enforce domain network cn_network : cpm::CPMNetwork {
			elements = cn_activity : cpm::Activity {
				name = name,
				duration = offset,
				sourceEvent = cn_sourceEvent,
				targetEvent = cn_targetEvent
			},
			elements = cn_predActivity : cpm::Activity{},
			elements = cn_succActivity : cpm::Activity{}
		};
		
		when {
			Diagram2Network(gd_diagram, cn_network);
			Activity2Activity (gd_predActivity, cn_predActivity);
			Activity2Activity (gd_succActivity, cn_succActivity);
			cn_sourceEvent = cn_predActivity.sourceEvent;
			cn_targetEvent = cn_succActivity.sourceEvent;
			name = cn_predActivity.name + '->' + cn_succActivity.name;
			-- Better use a domain condition here, which, however,
			-- is not supported in medini QVT. According to Section
			-- 7.5 of the standard, the domain condition can be used
			-- to bind a variable in the target domain pattern. 
			-- What about binding source and target event in the
			-- domain pattern, too? This would not work with the
			-- check-before-enforce semantics: In forward, when
			-- the check fails, enforcement means that all
			-- but the bound variables have to be instantiated -
			-- including source event and target event, which do
			-- not have a binding yet. However, the old events are
			-- not removed and thus are still part of the network.
			-- Furthermore, for the new events the link to the
			-- enclosing network is not set.
		}		
	}

    top relation StartEndDependency2Activity {
		offset : Integer;
		name : String;
		cn_sourceEvent, cn_targetEvent : cpm::Event;
		
		enforce domain diagram gd_diagram : gantt::GanttDiagram {
			elements = gd_dependency : gantt::Dependency {
				offset = offset,
				predecessor = gd_predActivity : gantt::Activity{},
				successor = gd_succActivity : gantt::Activity{},
				dependencyType = gantt::DependencyType::StartEnd
			}
		};
		
		enforce domain network cn_network : cpm::CPMNetwork {
			elements = cn_activity : cpm::Activity {
				name = name,
				duration = offset,
				sourceEvent = cn_sourceEvent,
				targetEvent = cn_targetEvent
			},
			elements = cn_predActivity : cpm::Activity{},
			elements = cn_succActivity : cpm::Activity{}
		};
		
		when {
			Diagram2Network(gd_diagram, cn_network);
			Activity2Activity (gd_predActivity, cn_predActivity);
			Activity2Activity (gd_succActivity, cn_succActivity);
			cn_sourceEvent = cn_predActivity.sourceEvent;
			cn_targetEvent = cn_succActivity.targetEvent;
			name = cn_predActivity.name + '->' + cn_succActivity.name;
		}		
	}
	
    top relation EndStartDependency2Activity {
		offset : Integer;
		name : String;
		cn_sourceEvent, cn_targetEvent : cpm::Event;
		
		enforce domain diagram gd_diagram : gantt::GanttDiagram {
			elements = gd_dependency : gantt::Dependency {
				offset = offset,
				predecessor = gd_predActivity : gantt::Activity{},
				successor = gd_succActivity : gantt::Activity{},
				dependencyType = gantt::DependencyType::EndStart
			}
		};
		
		enforce domain network cn_network : cpm::CPMNetwork {
			elements = cn_activity : cpm::Activity {
				name = name,
				duration = offset,
				sourceEvent = cn_sourceEvent,
				targetEvent = cn_targetEvent
			},
			elements = cn_predActivity : cpm::Activity{},
			elements = cn_succActivity : cpm::Activity{}
		};
		
		when {
			Diagram2Network(gd_diagram, cn_network);
			Activity2Activity (gd_predActivity, cn_predActivity);
			Activity2Activity (gd_succActivity, cn_succActivity);
			cn_sourceEvent = cn_predActivity.targetEvent;
			cn_targetEvent = cn_succActivity.sourceEvent;
			name = cn_predActivity.name + '->' + cn_succActivity.name;
		}		
	}

    top relation EndEndDependency2Activity {
		offset : Integer;
		name : String;
		cn_sourceEvent, cn_targetEvent : cpm::Event;
		
		enforce domain diagram gd_diagram : gantt::GanttDiagram {
			elements = gd_dependency : gantt::Dependency {
				offset = offset,
				predecessor = gd_predActivity : gantt::Activity{},
				successor = gd_succActivity : gantt::Activity{},
				dependencyType = gantt::DependencyType::EndEnd
			}
		};
		
		enforce domain network cn_network : cpm::CPMNetwork {
			elements = cn_activity : cpm::Activity {
				name = name,
				duration = offset,
				sourceEvent = cn_sourceEvent,
				targetEvent = cn_targetEvent
			},
			elements = cn_predActivity : cpm::Activity{},
			elements = cn_succActivity : cpm::Activity{}
		};
		
		when {
			Diagram2Network(gd_diagram, cn_network);
			Activity2Activity (gd_predActivity, cn_predActivity);
			Activity2Activity (gd_succActivity, cn_succActivity);
			cn_sourceEvent = cn_predActivity.targetEvent;
			cn_targetEvent = cn_succActivity.targetEvent;
			name = cn_predActivity.name + '->' + cn_succActivity.name;
		}		
	}


	
	query maxEventNumber(cn_network : cpm::CPMNetwork) : Integer {
		maximum(
			cn_network.elements->
				select(e | e.oclIsTypeOf(cpm::Event))
					->collect(e | e.oclAsType(cpm::Event)).number)
	} -- It seems that medini QVT does not support max on collections
	
	query maximum(s : Sequence(Integer)) : Integer {
		if s->isEmpty() then
			0
		else
			s->first().max(maximum(s->subSequence(2, s->size())))
		endif
	}

    query containsSubstring(s : String, sub : String) : Boolean {
    	not (s.indexOf(sub) < 0)
    	/* Not conforming with OCL specification: 0 should be returned
    	 * if substring is not found
    	*/
    }
    
    query separator() : String {'->'}
    
	query nameOfDependency(name : String) : Boolean {
    	containsSubstring(name, separator())
    }
	/* A name containing '->' designates a dependency activity,
	 * i.e., an activity in a CPM network which represents a dependency.
	 * Note than an activity in a Gantt Diagram must not contain '->'.
	 *
	 */ 
	 	
	query nameOfActivity(name : String) : Boolean {
		not nameOfDependency(name)
	}

	

}